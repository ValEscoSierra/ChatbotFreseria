/** 
* NO TOCAR ESTE ARCHIVO: Es generado automaticamente, si sabes lo que haces adelante ;)
* de lo contrario mejor ir a la documentacion o al servidor de discord link.codigoencasa.com/DISCORD
*/
'use strict';

function isInsideAddActionOrAddAnswer$4(node) {
    let currentNode = node;
    while (currentNode) {
        if (
            currentNode.type === 'CallExpression' &&
            currentNode.callee &&
            currentNode.callee.property &&
            (currentNode.callee.property.name === 'addAnswer' || currentNode.callee.property.name === 'addAction')
        ) {
            return true
        }
        currentNode = currentNode.parent;
    }
    return false
}

const processGotoFlowReturn$1 = (context) => {
    return {
        'CallExpression[callee.name="gotoFlow"]'(node) {
            let parentNode = node.parent;

            // Verificar si estamos dentro de un 'addAction' o 'addAnswer'
            if (!isInsideAddActionOrAddAnswer$4(node)) {
                return
            }

            // Verificar si nodo padre es de tipo ReturnStatement, si no lo es, reportar
            if (parentNode.type !== 'ReturnStatement') {
                context.report({
                    node,
                    message: 'Please ensure "gotoFlow" function is returned',
                    fix: function (fixer) {
                        return fixer.insertTextBefore(node, 'return ')
                    },
                });
            }
        },
    }
};

var processGotoFlowReturn_1 = { processGotoFlowReturn: processGotoFlowReturn$1 };

function isInsideAddActionOrAddAnswer$3(node) {
    let currentNode = node;
    while (currentNode) {
        if (
            currentNode.type === 'CallExpression' &&
            currentNode.callee &&
            currentNode.callee.property &&
            (currentNode.callee.property.name === 'addAnswer' || currentNode.callee.property.name === 'addAction')
        ) {
            return true
        }
        currentNode = currentNode.parent;
    }
    return false
}

const processDynamicFlowAwait$1 = (context) => {
    return {
        'CallExpression[callee.name="flowDynamic"]'(node) {
            let parentNode = node.parent;

            // Verificar si estamos dentro de un 'addAction' o 'addAnswer'
            if (!isInsideAddActionOrAddAnswer$3(node)) {
                return
            }

            // Verificar si el nodo padre es 'AwaitExpression', de lo contrario se reporta
            if (parentNode.type !== 'AwaitExpression') {
                context.report({
                    node,
                    message: 'Please use "await" before "flowDynamic" function',
                    fix: function (fixer) {
                        return fixer.insertTextBefore(node, 'await ')
                    },
                });
            }
        },
    }
};

var processDynamicFlowAwait_1 = { processDynamicFlowAwait: processDynamicFlowAwait$1 };

function isInsideAddActionOrAddAnswer$2(node) {
    let currentNode = node;
    while (currentNode) {
        if (
            currentNode.type === 'CallExpression' &&
            currentNode.callee &&
            currentNode.callee.property &&
            (currentNode.callee.property.name === 'addAnswer' || currentNode.callee.property.name === 'addAction')
        ) {
            return true
        }
        currentNode = currentNode.parent;
    }
    return false
}

const processStateUpdateAwait$1 = (context) => {
    return {
        'MemberExpression[property.name="update"]'(node) {
            // Verificar si el objeto es 'state'
            if (node.object.name !== 'state') {
                return
            }

            if (node.object.name === 'state') {
                const sourceCode = context.getSourceCode();
                const rangeStart = node.range[0] - 6; // Longitud de "await "
                const rangeEnd = node.range[0];
                const parentNodeText = sourceCode.getText().substring(rangeStart, rangeEnd);
                if (parentNodeText.includes('await')) {
                    return
                }
            }

            let parentNode = node.parent;
            // Verificar si estamos dentro de un 'addAction' o 'addAnswer'
            if (!isInsideAddActionOrAddAnswer$2(node)) {
                return
            }

            // Verificar si el nodo padre es 'AwaitExpression', de lo contrario se reporta
            if (parentNode.type !== 'AwaitExpression') {
                context.report({
                    node,
                    message: 'Please use "await" before "state.update"',
                    fix: function (fixer) {
                        // Comprueba si existe un await antes de state.update
                        const sourceCode = context.getSourceCode();
                        const rangeStart = node.range[0] - 7; // Longitud de "await "
                        const rangeEnd = node.range[0];
                        const parentNodeText = sourceCode.getText().substring(rangeStart, rangeEnd);

                        if (parentNodeText.trim() !== 'await') {
                            return fixer.insertTextBefore(node, 'await ')
                        }
                    },
                });
            }
        },
    }
};

var processStateUpdateAwait_1 = { processStateUpdateAwait: processStateUpdateAwait$1 };

function isInsideAddActionOrAddAnswer$1(node) {
    let currentNode = node;
    while (currentNode) {
        if (
            currentNode.type === 'CallExpression' &&
            currentNode.callee &&
            currentNode.callee.property &&
            (currentNode.callee.property.name === 'addAnswer' || currentNode.callee.property.name === 'addAction')
        ) {
            return true
        }
        currentNode = currentNode.parent;
    }
    return false
}

const processFallBackReturn$1 = (context) => {
    return {
        'CallExpression[callee.name="fallBack"]'(node) {
            let parentNode = node.parent;

            // Verificar si estamos dentro de un 'addAction' o 'addAnswer'
            if (!isInsideAddActionOrAddAnswer$1(node)) {
                return
            }

            // Verificar si nodo padre es de tipo ReturnStatement, si no lo es, reportar
            if (parentNode.type !== 'ReturnStatement') {
                context.report({
                    node,
                    message: 'Please ensure "fallBack" function is returned',
                    fix: function (fixer) {
                        return fixer.insertTextBefore(node, 'return ')
                    },
                });
            }
        },
    }
};

var processFallBackReturn_1 = { processFallBackReturn: processFallBackReturn$1 };

function isInsideAddActionOrAddAnswer(node) {
    let currentNode = node;
    while (currentNode) {
        if (
            currentNode.type === 'CallExpression' &&
            currentNode.callee &&
            currentNode.callee.property &&
            (currentNode.callee.property.name === 'addAnswer' || currentNode.callee.property.name === 'addAction')
        ) {
            return true
        }
        currentNode = currentNode.parent;
    }
    return false
}

const processEndFlowReturn$1 = (context) => {
    return {
        'CallExpression[callee.name="endFlow"]'(node) {
            let parentNode = node.parent;

            // Verificar si estamos dentro de un 'addAction' o 'addAnswer'
            if (!isInsideAddActionOrAddAnswer(node)) {
                return
            }

            // Verificar si nodo padre es de tipo ReturnStatement, si no lo es, reportar
            if (parentNode.type !== 'ReturnStatement') {
                context.report({
                    node,
                    message: 'Please ensure "endFlow" function is returned',
                    fix: function (fixer) {
                        return fixer.insertTextBefore(node, 'return ')
                    },
                });
            }
        },
    }
};

var processEndFlowReturn_1 = { processEndFlowReturn: processEndFlowReturn$1 };

var recommended = {
    rules: {
        'bot-whatsapp/func-prefix-goto-flow-return': 2,
        'bot-whatsapp/func-prefix-end-flow-return': 2,
        'bot-whatsapp/func-prefix-dynamic-flow-await': 2,
        'bot-whatsapp/func-prefix-state-update-await': 2,
        'bot-whatsapp/func-prefix-fall-back-return': 2,
    },
};

const { processGotoFlowReturn } = processGotoFlowReturn_1;
const { processDynamicFlowAwait } = processDynamicFlowAwait_1;
const { processStateUpdateAwait } = processStateUpdateAwait_1;
const { processFallBackReturn } = processFallBackReturn_1;
const { processEndFlowReturn } = processEndFlowReturn_1;

var eslintPluginBotWhatsapp = {
    configs: {
        recommended: recommended,
    },
    rules: {
        'func-prefix-goto-flow-return': {
            meta: {
                fixable: 'code',
            },
            create: processGotoFlowReturn,
        },
        'func-prefix-fall-back-return': {
            meta: {
                fixable: 'code',
            },
            create: processFallBackReturn,
        },
        'func-prefix-end-flow-return': {
            meta: {
                fixable: 'code',
            },
            create: processEndFlowReturn,
        },
        'func-prefix-dynamic-flow-await': {
            meta: {
                fixable: 'code',
            },
            create: processDynamicFlowAwait,
        },
        'func-prefix-state-update-await': {
            meta: {
                fixable: 'code',
            },
            create: processStateUpdateAwait,
        },
    },
};

module.exports = eslintPluginBotWhatsapp;
